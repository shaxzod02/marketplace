{"_id":"@standard-schema/spec","_rev":"4-d43384b1e8c568a68fb28783d358e9b6","name":"@standard-schema/spec","dist-tags":{"latest":"1.0.0-beta.4"},"versions":{"1.0.0-beta.0":{"name":"@standard-schema/spec","version":"1.0.0-beta.0","keywords":["typescript","schema","validation","standard","interface"],"author":{"name":"Colin McDonnell"},"license":"MIT","_id":"@standard-schema/spec@1.0.0-beta.0","maintainers":[{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},{"name":"colinhacks","email":"colinmcd94@gmail.com"}],"homepage":"https://github.com/standard-schema/standard-schema#readme","bugs":{"url":"https://github.com/standard-schema/standard-schema/issues"},"dist":{"shasum":"fa7afa617aa6a485b66fdc3e1df7ab6a903024a7","tarball":"https://registry.npmjs.org/@standard-schema/spec/-/spec-1.0.0-beta.0.tgz","fileCount":7,"integrity":"sha512-//opTrDGFcAaG8BNc0btA5wwU1V573X/UezT5jgfwucdZEbzukpKCsFUJVskH6aJ3KNVOXdSbhS4YWFfnyLVbA==","signatures":[{"sig":"MEUCIEBy85HFn8vwfDO5c4Lf0d8v3EZsaYc2RCPD02prlK2EAiEArW5bocywnDi5ZOrVTdKLbddiDHBKX6lgSMc3mn/H82M=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":16949},"main":"./dist/index.js","type":"module","types":"./dist/index.d.ts","exports":{".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"}}},"gitHead":"889b3918f64c418aabd0de40dd0d0e35258f6022","scripts":{"lint":"pnpm biome lint ./src","test":"vitest --typecheck","build":"tsup","check":"pnpm biome check ./src","format":"pnpm biome format --write ./src"},"_npmUser":{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},"repository":{"url":"git+https://github.com/standard-schema/standard-schema.git","type":"git"},"_npmVersion":"10.8.0","description":"A standard interface for TypeScript schema validation libraries","directories":{},"sideEffects":false,"_nodeVersion":"20.11.0","publishConfig":{"access":"public"},"_hasShrinkwrap":false,"devDependencies":{"tsup":"^8.3.0","typescript":"^5.6.2","@biomejs/biome":"^1.9.2"},"_npmOperationalInternal":{"tmp":"tmp/spec_1.0.0-beta.0_1727406475833_0.4525958237428134","host":"s3://npm-registry-packages"}},"1.0.0-beta.1":{"name":"@standard-schema/spec","version":"1.0.0-beta.1","keywords":["typescript","schema","validation","standard","interface"],"author":{"name":"Colin McDonnell"},"license":"MIT","_id":"@standard-schema/spec@1.0.0-beta.1","maintainers":[{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},{"name":"colinhacks","email":"colinmcd94@gmail.com"}],"homepage":"https://github.com/standard-schema/standard-schema#readme","bugs":{"url":"https://github.com/standard-schema/standard-schema/issues"},"dist":{"shasum":"dbd8e08cdb014bd113ae10a9f9a87354f86b55b5","tarball":"https://registry.npmjs.org/@standard-schema/spec/-/spec-1.0.0-beta.1.tgz","fileCount":7,"integrity":"sha512-XFHxCgvFiNrofjsZ1SFLKjLSo6kM9WITBU6gPnkKtrQ6fSuPWhZ/7gLTWmMcMprFgN4FfU1Wcsr5+jNkRaksCQ==","signatures":[{"sig":"MEUCIAcCnPV/FmHA1YJCZibWB+EcACTI9bLQDQtPsxPz138GAiEA0Gc6iihVlL815adsfySqf1eMEWitsLGj5y7Sr5Jvr78=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/@standard-schema%2fspec@1.0.0-beta.1","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":22820},"main":"./dist/index.js","type":"module","_from":"file:standard-schema-spec-1.0.0-beta.1.tgz","types":"./dist/index.d.ts","exports":{".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"}}},"scripts":{"lint":"pnpm biome lint ./src","build":"tsup","check":"pnpm biome check ./src","format":"pnpm biome format --write ./src"},"_npmUser":{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},"_resolved":"/tmp/9d9ecae5223ede7ea4617dbcdb0ee0b5/standard-schema-spec-1.0.0-beta.1.tgz","_integrity":"sha512-XFHxCgvFiNrofjsZ1SFLKjLSo6kM9WITBU6gPnkKtrQ6fSuPWhZ/7gLTWmMcMprFgN4FfU1Wcsr5+jNkRaksCQ==","repository":{"url":"git+https://github.com/standard-schema/standard-schema.git","type":"git"},"_npmVersion":"10.8.2","description":"A standard interface for TypeScript schema validation libraries","directories":{},"sideEffects":false,"_nodeVersion":"20.17.0","publishConfig":{"access":"public"},"_hasShrinkwrap":false,"devDependencies":{"tsup":"^8.3.0","typescript":"^5.6.2"},"_npmOperationalInternal":{"tmp":"tmp/spec_1.0.0-beta.1_1728191700871_0.045437036406358766","host":"s3://npm-registry-packages"}},"1.0.0-beta.2":{"name":"@standard-schema/spec","version":"1.0.0-beta.2","keywords":["typescript","schema","validation","standard","interface"],"author":{"name":"Colin McDonnell"},"license":"MIT","_id":"@standard-schema/spec@1.0.0-beta.2","maintainers":[{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},{"name":"colinhacks","email":"colinmcd94@gmail.com"}],"homepage":"https://github.com/standard-schema/standard-schema#readme","bugs":{"url":"https://github.com/standard-schema/standard-schema/issues"},"dist":{"shasum":"12ce88bcf5047a026c1d3c513403d91e2a71f08e","tarball":"https://registry.npmjs.org/@standard-schema/spec/-/spec-1.0.0-beta.2.tgz","fileCount":7,"integrity":"sha512-3xO2jovtlaUYPgj6lTL5rgRnKiPyXQXwUmYlQBu2WcTNHrFdbQZ7nrOcqSEtDeRISvv4rQdbBf60xjnT5+tssg==","signatures":[{"sig":"MEQCICn4rMsq2dfSrAxQAKmvFxLpTkJQFaVpwuHkrpv6vPCNAiBxKCTu76t1HyetbzuBicAbvYSczzvSak4WZYJ0QhEGsA==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/@standard-schema%2fspec@1.0.0-beta.2","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":22009},"main":"./dist/index.js","type":"module","_from":"file:standard-schema-spec-1.0.0-beta.2.tgz","types":"./dist/index.d.ts","exports":{".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"}}},"scripts":{"lint":"pnpm biome lint ./src","build":"tsup","check":"pnpm biome check ./src","format":"pnpm biome format --write ./src"},"_npmUser":{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},"_resolved":"/tmp/892e4ef63115df7974237d62099d74a1/standard-schema-spec-1.0.0-beta.2.tgz","_integrity":"sha512-3xO2jovtlaUYPgj6lTL5rgRnKiPyXQXwUmYlQBu2WcTNHrFdbQZ7nrOcqSEtDeRISvv4rQdbBf60xjnT5+tssg==","repository":{"url":"git+https://github.com/standard-schema/standard-schema.git","type":"git"},"_npmVersion":"10.8.2","description":"A standard interface for TypeScript schema validation libraries","directories":{},"sideEffects":false,"_nodeVersion":"20.18.0","publishConfig":{"access":"public"},"_hasShrinkwrap":false,"devDependencies":{"tsup":"^8.3.0","typescript":"^5.6.2"},"_npmOperationalInternal":{"tmp":"tmp/spec_1.0.0-beta.2_1731033826261_0.26730841655125803","host":"s3://npm-registry-packages"}},"1.0.0-beta.3":{"name":"@standard-schema/spec","version":"1.0.0-beta.3","keywords":["typescript","schema","validation","standard","interface"],"author":{"name":"Colin McDonnell"},"license":"MIT","_id":"@standard-schema/spec@1.0.0-beta.3","maintainers":[{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},{"name":"colinhacks","email":"colinmcd94@gmail.com"}],"homepage":"https://github.com/standard-schema/standard-schema#readme","bugs":{"url":"https://github.com/standard-schema/standard-schema/issues"},"dist":{"shasum":"4dbf9a3c69e10fa2997e1ac1f39d8e9f33213576","tarball":"https://registry.npmjs.org/@standard-schema/spec/-/spec-1.0.0-beta.3.tgz","fileCount":7,"integrity":"sha512-0ifF3BjA1E8SY9C+nUew8RefNOIq0cDlYALPty4rhUm8Rrl6tCM8hBT4bhGhx7I7iXD0uAgt50lgo8dD73ACMw==","signatures":[{"sig":"MEYCIQC+VoQ/meJ9ua6D9mSyzOPrH3kJEGIkpWn2j/rsfEgbngIhANcXvrgnvLdDMH96mjeAL3LvvNYvrKQrZWAkbf72wx9k","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/@standard-schema%2fspec@1.0.0-beta.3","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":21965},"main":"./dist/index.js","type":"module","_from":"file:standard-schema-spec-1.0.0-beta.3.tgz","types":"./dist/index.d.ts","exports":{".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"}}},"scripts":{"lint":"pnpm biome lint ./src","build":"tsup","check":"pnpm biome check ./src","format":"pnpm biome format --write ./src"},"_npmUser":{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},"_resolved":"/tmp/7bb72f693054619c52b3bf56cb8fba7c/standard-schema-spec-1.0.0-beta.3.tgz","_integrity":"sha512-0ifF3BjA1E8SY9C+nUew8RefNOIq0cDlYALPty4rhUm8Rrl6tCM8hBT4bhGhx7I7iXD0uAgt50lgo8dD73ACMw==","repository":{"url":"git+https://github.com/standard-schema/standard-schema.git","type":"git"},"_npmVersion":"10.8.2","description":"A standard interface for TypeScript schema validation libraries","directories":{},"sideEffects":false,"_nodeVersion":"20.18.0","publishConfig":{"access":"public"},"_hasShrinkwrap":false,"devDependencies":{"tsup":"^8.3.0","typescript":"^5.6.2"},"_npmOperationalInternal":{"tmp":"tmp/spec_1.0.0-beta.3_1731079172134_0.07887131885754095","host":"s3://npm-registry-packages"}},"1.0.0-beta.4":{"name":"@standard-schema/spec","description":"A standard interface for TypeScript schema validation libraries","version":"1.0.0-beta.4","license":"MIT","author":{"name":"Colin McDonnell"},"repository":{"type":"git","url":"git+https://github.com/standard-schema/standard-schema.git"},"keywords":["typescript","schema","validation","standard","interface"],"type":"module","main":"./dist/index.js","types":"./dist/index.d.ts","exports":{".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"}}},"sideEffects":false,"publishConfig":{"access":"public"},"devDependencies":{"tsup":"^8.3.0","typescript":"^5.6.2"},"scripts":{"lint":"pnpm biome lint ./src","format":"pnpm biome format --write ./src","check":"pnpm biome check ./src","build":"tsup"},"_id":"@standard-schema/spec@1.0.0-beta.4","bugs":{"url":"https://github.com/standard-schema/standard-schema/issues"},"homepage":"https://github.com/standard-schema/standard-schema#readme","_integrity":"sha512-d3IxtzLo7P1oZ8s8YNvxzBUXRXojSut8pbPrTYtzsc5sn4+53jVqbk66pQerSZbZSJZQux6LkclB/+8IDordHg==","_resolved":"/tmp/6810b23ee344392dfe6c2a2d68058f41/standard-schema-spec-1.0.0-beta.4.tgz","_from":"file:standard-schema-spec-1.0.0-beta.4.tgz","_nodeVersion":"20.18.1","_npmVersion":"10.8.2","dist":{"integrity":"sha512-d3IxtzLo7P1oZ8s8YNvxzBUXRXojSut8pbPrTYtzsc5sn4+53jVqbk66pQerSZbZSJZQux6LkclB/+8IDordHg==","shasum":"62f520109add3eb016004098363bfee0678dd1ec","tarball":"https://registry.npmjs.org/@standard-schema/spec/-/spec-1.0.0-beta.4.tgz","fileCount":7,"unpackedSize":22022,"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/@standard-schema%2fspec@1.0.0-beta.4","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEpvwjJcMU+mZ1xK/1//eYw0wIWgzcWSaGdnd0zGi5rsAiBwNiXbZPoy+sg2FTa9K53BuND3gxxLFiZZRM2bUe5LqA=="}]},"_npmUser":{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},"directories":{},"maintainers":[{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},{"name":"colinhacks","email":"colinmcd94@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/spec_1.0.0-beta.4_1732749296479_0.3601810032693309"},"_hasShrinkwrap":false}},"time":{"created":"2024-09-27T03:07:55.745Z","modified":"2024-11-27T23:14:57.163Z","1.0.0-beta.0":"2024-09-27T03:07:56.009Z","1.0.0-beta.1":"2024-10-06T05:15:01.110Z","1.0.0-beta.2":"2024-11-08T02:43:46.442Z","1.0.0-beta.3":"2024-11-08T15:19:32.347Z","1.0.0-beta.4":"2024-11-27T23:14:56.722Z"},"bugs":{"url":"https://github.com/standard-schema/standard-schema/issues"},"author":{"name":"Colin McDonnell"},"license":"MIT","homepage":"https://github.com/standard-schema/standard-schema#readme","keywords":["typescript","schema","validation","standard","interface"],"repository":{"type":"git","url":"git+https://github.com/standard-schema/standard-schema.git"},"description":"A standard interface for TypeScript schema validation libraries","maintainers":[{"name":"fabian-hiller","email":"hillerfabian11@gmail.com"},{"name":"colinhacks","email":"colinmcd94@gmail.com"}],"readme":"# Standard Schema Spec\n\nA consortium of schema library authors have collaborated to craft a standard interface for schema libraries to benefit the entire JavaScript ecosystem. Standard Schema provides third-party libraries a uniform integration to automatically support multiple schema libraries at once, without adding a single runtime dependency. This simplifies implementation, prevents vendor lock-in, and enables innovation, especially for smaller schema libraries with new ideas. For more information on the origins and use cases of Standard Schema, see [background](#background).\n\n## The Interface\n\nThe Standard Schema interface is a set of validation-related properties that must be defined under a key called `~standard`.\n\n```ts\nexport interface StandardSchemaV1<Input = unknown, Output = Input> {\n  readonly \"~standard\": {\n    /**\n     * The version number of the standard.\n     */\n    readonly version: 1;\n    /**\n     * The vendor name of the schema library.\n     */\n    readonly vendor: string;\n    /**\n     * Validates unknown input values.\n     */\n    readonly validate: (\n      value: unknown,\n    ) => Result<Output> | Promise<Result<Output>>;\n    /**\n     * Inferred types associated with the schema.\n     */\n    readonly types?: Types<Input, Output> | undefined;\n  };\n}\n```\n\n- `~standard` contains the Standard Schema properties and can be used to test whether an object is a Standard Schema. \n  - `version` defines the version number of the standard. This can be used in the future to distinguish between different versions of the standard.\n  - `vendor` stores the name of the schema libarry. This can be useful for performing vendor-specific operations in special cases. \n  - `validate` is a function that validates unknown input and returns the output of the schema if the input is valid or an array of issues otherwise. This can be discriminated by checking whether the `issues` property is `undefined`.\n  - `types` is used to associate type metadata with the schema. This property should be declared on the schema's type, but is not required to exist at runtime. Authors implementing a schema using a class are encouraged to use TypeScript's `declare` keyword or other means to avoid runtime overhead. `InferInput` and `InferOutput` can be used to extract their corresponding types.\n\n## Implementation\n\nTwo parties are required for Standard Schema to work. First, the schema libraries that implement the standard interface, and second, the third-party libraries that accept schemas as part of their API that follow the standard interface.\n\n### Schema Library\n\nSchemas libraries that want to support Standard Schema must implement its interface. This includes adding the `~standard` property. To make this process easier, schema libraries can optionally extend their interface from the `StandardSchemaV1` interface.\n\n> It doesn't matter whether your schema library returns plain objects, functions, or class instances. The only thing that matters is that the `~standard` property is defined somehow.\n\n```ts\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\n\n// Step 1: Define the schema interface\ninterface StringSchema extends StandardSchemaV1<string> {\n  type: \"string\";\n  message: string;\n}\n\n// Step 2: Implement the schema interface\nfunction string(message: string = \"Invalid type\"): StringSchema {\n  return {\n    type: \"string\",\n    message,\n    \"~standard\": {\n      version: 1,\n      vendor: \"valizod\",\n      validate(value) {\n        return typeof value === \"string\"\n          ? { value }\n          : { issues: [{ message }] };\n      },\n    },\n  };\n}\n```\n\nInstead of implementing the `StandardSchemaV1` interface natively into your library code, you can also just add it on top and reuse your existing functions and methods within the `validate` function.\n\n### Third Party\n\nOther than for schema library authors, we recommend third party authors to install the `@standard-schema/spec` package when implementing Standard Schema into their libraries. This package provides the `StandardSchemaV1` interface and the `InferInput` and `InferOutput` utility types.\n\n```sh\nnpm install @standard-schema/spec --save-dev  # npm\nyarn add @standard-schema/spec --dev          # yarn\npnpm add @standard-schema/spec --dev          # pnpm\nbun add @standard-schema/spec --dev           # bun\ndeno add jsr:@standard-schema/spec --dev      # deno\n```\n\n> Alternatively, you can also copy and paste [the types](https://github.com/standard-schema/standard-schema/blob/main/packages/spec/src/index.ts) into your project.\n\nAfter that you can accept any schemas that implement the Standard Schema interface as part of your API. We recommend using a generic that extends the `StandardSchemaV1` interface in most cases to be able to infer the type information of the schema.\n\n```ts\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\n\n// Step 1: Define the schema generic\nfunction createEndpoint<TSchema extends StandardSchemaV1, TOutput>(\n  // Step 2: Use the generic to accept a schema\n  schema: TSchema,\n  // Step 3: Infer the output type from the generic\n  handler: (data: StandardSchemaV1.InferOutput<TSchema>) => Promise<TOutput>,\n) {\n  return async (data: unknown) => {\n    // Step 4: Use the schema to validate data\n    const result = await schema[\"~standard\"].validate(data);\n\n    // Step 5: Process the validation result\n    if (result.issues) {\n      throw new Error(result.issues[0].message ?? \"Validation failed\");\n    }\n    return handler(result.value);\n  };\n}\n```\n\n#### Common Tasks\n\nThere are two common tasks that third-party libraries perform after validation fails. The first is to flatten the issues by creating a dot path to more easily associate the issues with the input data. This is commonly used in form libraries. The second is to throw an error that contains all the issue information.\n\n##### Get Dot Path\n\nTo generate a dot path, simply map and join the keys of an issue path, if available.\n\n```ts\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\n\nasync function getFormErrors(schema: StandardSchemaV1, data: unknown) {\n  const result = await schema[\"~standard\"].validate(data);\n  const formErrors: string[] = [];\n  const fieldErrors: Record<string, string[]> = {};\n  if (result.issues) {\n    for (const issue of result.issues) {\n      const dotPath = issue.path\n        ?.map((item) => (typeof item === \"object\" ? item.key : item))\n        .join(\".\");\n      if (dotPath) {\n        if (fieldErrors[dotPath]) {\n          fieldErrors[dotPath].push(issue.message);\n        } else {\n          fieldErrors[dotPath] = [issue.message];\n        }\n      } else {\n        formErrors.push(issue.message);\n      }\n    }\n  }\n  return { formErrors, fieldErrors };\n}\n```\n\n##### Schema Error\n\nTo throw an error that contains all issue information, simply pass the issues of the failed schema validation to a `SchemaError` class. The `SchemaError` class extends the `Error` class with an `issues` property that contains all the issues.\n\n```ts\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\n\nclass SchemaError extends Error {\n  public readonly issues: ReadonlyArray<StandardSchemaV1.Issue>;\n  constructor(issues: ReadonlyArray<StandardSchemaV1.Issue>) {\n    super(issues[0].message);\n    this.name = \"SchemaError\";\n    this.issues = issues;\n  }\n}\n\nasync function validateInput<TSchema extends StandardSchemaV1>(\n  schema: TSchema,\n  data: unknown,\n): Promise<StandardSchemaV1.InferOutput<TSchema>> {\n  const result = await schema[\"~standard\"].validate(data);\n  if (result.issues) {\n    throw new SchemaError(result.issues);\n  }\n  return result.value;\n}\n```\n\n## Ecosystem\n\nThese are the libraries that have already implemented the Standard Schema interface. Feel free to add your library to the list in ascending order by creating a pull request.\n\n### Schema Libraries\n\n- [ArkType](https://github.com/arktypeio/arktype): TypeScript's 1:1 validator, optimized from editor to runtime ‚õµ\n- [Valibot](https://github.com/fabian-hiller/valibot): The modular and type safe schema library for validating structural data ü§ñ\n\n### Third Parties\n\n- [GQLoom](https://github.com/modevol-com/gqloom): Weave GraphQL schema and resolvers using Standard Schema.\n- [Nuxt UI](https://github.com/nuxt/ui): A UI Library for Modern Web Apps, powered by Vue & Tailwind CSS.\n- [TanStack Router](https://github.com/tanstack/router): A fully type-safe React router with built-in data fetching, stale-while revalidate caching and first-class search-param APIs.\n- [tRPC](https://github.com/trpc/trpc): üßô‚Äç‚ôÄÔ∏è Move Fast and Break Nothing. End-to-end typesafe APIs made easy.\n\n## Background\n\n### The Problem\n\nValidation is an essential building block for almost any application. Therefore, it was no surprise to see more and more JavaScript frameworks and libraries start to natively support specific schema libraries. Frameworks like Astro and libraries like the OpenAI SDK have adopted Zod in recent months to streamline the experience for their users. But to be honest, the current situation is far from perfect. Either only a single schema library gets first-party support, because the implementation and maintenance of multiple schema libraries is too complicated and time-consuming, or the choice falls on an adapter or resolver pattern, which is more cumbersome to implement for both sides.\n\nFor this reason, Colin McDonnell, the creator of Zod, came up with [the idea](https://x.com/colinhacks/status/1634284724796661761) of a standard interface for schema libraries. This interface should be minimal, easy to implement, but powerful enough to support the most important features of popular schema libraries. The goal was to make it easier for other libraries to accept user-defined schemas as part of their API, in a library-agnostic way. After much thought and consideration, Standard Schema was born.\n\n### Use Cases\n\nThe first version of Standard Schemas aims to address the most common use cases of schema libraries today. This includes API libraries like tRPC and JavaScript frameworks like Astro and Qwik who secure the client/server communication in a type safe way using schemas. Or projects like the T3 Stack, which uses schemas to validate environment variables. It also includes UI libraries like Nuxt UI and form libraries like Reach Hook Form, which use schemas to validate user inputs. Especially with the rise of TypeScript, schemas became the de facto standard as they drastically improved the developer experience by providing the type information and validation in a single source of truth.\n\nAt the moment, Standard Schema deliberately tries to cover only the most common use cases. However, we believe that other use cases, such as integrating schema libraries into AI SDKs like Vercel AI or the OpenAI SDK to generate structured output, can also benefit from a standard interface.\n\n## FAQ\n\nThese are the most frequently asked questions about Standard Schema. If your question is not listed, feel free to create an issue.\n\n### Do I need to include `@standard-schema/spec` as a dependency?\n\nNo. The `@standard-schema/spec` package is completely optional. You can just copy and paste the types into your project, or manually add the `~standard` properties to your existing types. But you can include `@standard-schema/spec` as a dev dependency and consume it exclusively with `import type`. The `@standard-schema/spec` package contains no runtime code and only exports types.\n\n### Why did you choose to prefix the `~standard` property with `~`?\n\nThe goal of prefixing the key with `~` is to both avoid conflicts with existing API surfaces and to de-prioritize these keys in auto-complete. The `~` character is one of the few ASCII characters that occurs after `A-Za-z0-9` lexicographically, so VS Code puts these suggestions at the bottom of the list.\n\n![Screenshot showing the de-prioritization of the `~` prefix keys in VS Code.](https://github.com/standard-schema/standard-schema/assets/3084745/5dfc0219-7531-481e-9691-cff5bc471378)\n\n### Why don't you use symbols for the keys instead of the `~` prefix?\n\nIn TypeScript, using a plain `Symbol` inline as a key always collapses to a simple `symbol` type. This would cause conflicts with other schema properties that use symbols.\n\n```ts\nconst object = {\n  [Symbol.for('~output')]: 'some data',\n};\n// { [k: symbol]: string }\n```\n\nBy contrast, declaring the symbol externally makes it \"nominally typed\". This means that the key is sorted in autocomplete under the variable name (e.g. `testSymbol` below). Thus, these symbol keys don't get sorted to the bottom of the autocomplete list, unlike `~`-prefixed string keys.\n\n![Screenshot showing the prioritization of external symbols in VS Code](https://github.com/standard-schema/standard-schema/assets/3084745/82c47820-90c3-4163-a838-858b987a6bea)\n\n### What should I do if I only accept synchronous validation?\n\nThe `~validate` function does not necessarily have to return a `Promise`. If you only accept synchronous validation, you can simply throw an error if the returned value is an instance of the `Promise` class.\n\n```ts\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\n\nfunction validateInput(schema: StandardSchemaV1, data: unknown) {\n  const result = schema[\"~standard\"].validate(data);\n  if (result instanceof Promise) {\n    throw new TypeError('Schema validation must be synchronous');\n  }\n  // ...\n}\n```\n","readmeFilename":"README.md"}